# COM3529 Software Testing & Analysis Assignment - Spring 2021

## Project Contributors: 
&nbsp;&nbsp; Andrew Payne - apayne5@sheffield.ac.uk \
&nbsp;&nbsp; Ambrose Robinson - arobinson10@sheffield.ac.uk

## Overview

As per the assignment brief set out by the lecturer, this program aims to provide an automated testing 
framework by parsing Java files and automatically creating relevant tests.

Because this is a developmental assignment with no set *gold standard* to measure against, the 
following features have been implemented in this submission: 

* Parse Java file  automatically to obtain a list of methods and their parameters
* Parse Java file automatically to obtain a list of if branches and their conditions
* Generate test case suites in terms of meeting Restricted MCDC Coverage Criterion
* Generate test case suites in terms of meeting Branch Coverage Criterion
* Generate test case suites in terms of meeting Condition Coverage Criterion
* Generate J-Unit test cases automatically and parse to a java test file
* Generate configurably random integer, double, boolean, string and miscellaneous object inputs (see additional features)


## Technologies
* Java - JDK Version 11 
* JavaParser - Version 3.20.2 


## Launch/Setup

1. Place files you want to test inside the src directory somewhere, we recommend src/main/java/assignmentFiles/subjectFiles/ but anywhere will do
2. Run Main.java (it must be ran once to create the instrumented class and then a second time to create the test cases) with the following command line arguments:
	- argument 1 - coverage criteria out of branch, condition and MCDC
	- argument 2 - will be the path to the java file the user wants to instrument from src onwards e.g. src/main/java/assignmentFiles/subjectFiles/Triangle.java
	
	- **IF THE USER WANTS TO CONFIGURE INPUT PARAMETERS THEN ADD THE FOLLOWING ADDITIONAL ARGUMENTS:**
        - argument 3 - min_doub = minimum value for double generation
        - argument 4 - max_doub = maximum value for double generation
        - argument 5 - min_int = minimum value for integer generation
        - argument 6 - max_int = maximum value for integer generation
        - argument 7 - min_str_len = minimum length of strings generated in string generation
        - argument 8 - max_str_len = maximum length of strings generated in string generation
        - argument 9 - alphanumeric = boolean true if strings generated should be alphanumeric else alphabetic only
    
3. First execution of the program will create an instrumented file and an empty test class. Once this has been completed, re-run the program
   with the same arguments entered above to poulate the test class.


* Note that all classes used by the class to be instrumented must have an import statement for all classes that it references/uses even if said classes are in the same directory/package usually as the file gets taken out and put as Instrumented.java in the instrumentedFiles package

## Features

1. Logging statements recurse through multiple conditions inside conditonal statements to ensure each is correctly logged.

2. For the parser to correctly insert logging statements on branches, which involves adding additional lines, if statements are checked
   for parenthesis and added before branch logging begins

3. To ensure class files are not altered, an instrumented file with logging conditions and required functions are placed inside
   instrumentedFiles directory, and tests are run on this copy. As a result, the code will not pick up the newly created file
   during the first execution - rather it will create the required instrumented file and an empty test class file. To generate the
   populated test file, re-run Main.java without changing any of the arguments to complete the test creation.

4. The J-Unit test cases will then be created inside of autoGeneratedTests package inside the test directory, with their respective outputs. It is up to you, the user,
   to decide whether the outputs are correct and change them accordingly.

5. Test cases are named based on the method under test, and the binary sequence for all branches/condition ids relating to the test. This ensures there are no
   naming conflicts when creating test cases.

6. Tests cases contain the generated inputs, as well as an equal to assertion that matches the generated inputs results. In the case of an Enumerator class inside
   the target class, the method call is pre-pended with the class name.
## Limitations

* Switch cases are not supported within the instrumentation implementation.
* The names of the methods are used as keys in most of the
  hashmaps that hold the information about used for all the
  different types of coverage tracking and method input
  information for input generation. Because of this, overloaded
  methods are not considered when parsing, as its only the simple names
  (no package or full signature) of the methods used in this
  respect here. Therefore the program only works when passed
  classes without overloaded methods.
* Ternary if statements are not picked up by the Parser. Should you
  wish to have these automatically instrumented, then the code will need to be
  re-written as a normal if statement, then executed as normal to add conditonal loggers
  and branch loggers to the instrumented code.

* As discussed in Features point 3, once the code is compiled and executed, this version of the program does not recompile code
  during execution. Thus, to create a poplulated test class, the code will need to be re-executed once the instrumented file and
  empty test class has been created. The console will display a prompt indicating the relevant files have been created. No changes to input arguments
  are required to generate the test cases on the second execution